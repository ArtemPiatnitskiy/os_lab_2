Полезная информация

#### Что это?

Тут я собрал информацию, которая была для меня полезной, во время решения данной лабораторной работы.

В процессе решения возникают вопросы, в которых необходимо разобраться. Информацию я нахожу в интернете, или спрашиваю у нейросетей.

В случае, если у меня возникает какой-то вопрос, найденную информацию я сохраняю сюда.

Это помогает **глубже** разобраться в вопросе и сделать для себя материал, который поможет понять и запомнить важные моменты и понятия.

---

# 1. Основы: Процессы и Потоки (Threads)

Представим, что мы готовим ужин.

- **Процесс** — это вся кухня, где мы готовим. У неё есть свои ресурсы: плита, холодильник с продуктами, раковина, ножи. Когда мы запускаем программу (например, Word или нашу программу на C), операционная система выделяет для неё "кухню" — то есть, память и процессорное время.

- **Поток (Thread)** — это повар на этой кухне.
  
  - **Однопоточная программа:** На кухне работает только один повар. Он делает всё последовательно: сначала режет овощи, потом ставит кастрюлю на плиту, потом моет посуду. Если овощей много, всё остальное будет ждать.
  - **Многопоточная программа:** Мы позвали на помощь друзей, и теперь на кухне несколько "поваров" (потоков). Один повар режет овощи, другой в это же время варит суп, третий накрывает на стол. Все они работают **в рамках одной кухни (процесса)** и используют общие ресурсы (ножи, плиту, продукты).

**Ключевая идея:** Потоки — это единицы выполнения внутри одного процесса, которые могут работать параллельно (или псевдопараллельно на одноядерном процессоре) и совместно используют ресурсы процесса (память).

**Немного другое определение:** Поток — это "независимая линия выполнения" внутри программы. У потоков общий адрес (память), но у каждого свой стек и регистры. Потоки удобны, когда нужно делать несколько задач одновременно (например: одна читает сеть, другая — обрабатывает данные).

Итак:

- Процесс — это изолированная единица выполнения: у неё отдельное виртуальное адресное пространство, дескрипторы файлов и т.д.
- Поток (thread) — легковесный **поток выполнения** внутри процесса: разделяет адресное пространство и многие ресурсы с другими потоками процесса, но имеет собственный стек, регистры и состояние выполнения.
- Зачем потоки: параллелизм (на многоядерных системах) и упрощение модели конкурирующих задач внутри одного приложения (I/O-параллельность, responsive UI и т.п.).

# 2. Создание и Управление Потоками

В нашем задании указано "использовать стандартные средства создания потоков". Это означает:

- **Для Linux/Unix (и macOS):** Библиотека **POSIX Threads (pthreads)**. Это стандарт, который будем использовать в программе. Основные функции:
  
  - `pthread_create()`: Создать нового "повара" (поток).
  - `pthread_join()`: "Главный повар" ждёт, пока другой поток закончит свою работу.
  - `pthread_exit()`: Поток завершает свою работу.

- **Для Windows:** **Windows API**. Функции будут другими, например `CreateThread()`.

**Проблема:** Когда несколько поваров хотят использовать один и тот же нож одновременно, может возникнуть хаос. Один схватил, другой пытается вырвать — в итоге кто-то может порезаться. В программировании это называется **состояние гонки (race condition)**.

**Решение:** **Синхронизация**. Нужно ввести правила. Например, "нож может использовать только один повар за раз". Для этого есть специальные инструменты:

- **Мьютексы (Mutex - MUTual EXclusion):** Это как замок на ящике с ножом. Взял нож — закрыл ящик на ключ (заблокировал мьютекс). Закончил работу — положил нож и открыл ящик (разблокировал мьютекс). Другой повар, подойдя к закрытому ящику, будет ждать, пока он не откроется.

### 2.1 Модели потоков

- 1:1 (one-to-one): каждый пользовательский поток отображается на один системный (ядровой) поток — напр. pthreads на Linux, std::thread.
- M:N (many-to-many): несколько пользовательских потоков управляются на меньшее число системных — использовалось в некоторых реализациях, сейчас это редкость.
- Пользовательские потоки (green threads, goroutines) реализуются в пространстве пользователя и часто имеют меньшую стоимость создания/переключения; требуются рантайм и планировщик (пример: Go).

### 2.2 Как создать/управлять потоками (примеры)

POSIX pthreads (C)

### pthread_create()

- pthread_create(&tid, NULL, start_routine, arg)
  
  Сигнатура
  
  ```c
  int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
  ```
  
  - thread: выходной аргумент — идентификатор создаваемого потока (тип pthread_t).
    
    Другими словами — куда положат идентификатор нового потока (типа pthread_t).
  
  - attr: если NULL — используются значения по умолчанию; иначе — указатель на структуру атрибутов.
    
    `attr` — это указатель на структуру `pthread_attr_t`, которая содержит атрибуты для нового потока. Эти атрибуты, такие как размер стека, политика планирования и т.д., определяют поведение нового потока. Если `attr` равен `NULL`, используются атрибуты потока по умолчанию.
    
    Пример использования атрибутов:
    Следующий пример показывает, как создать поток в отсоединённом состоянии, чтобы не вызывать pthread_join(), если его результат не нужен:
    
    ```c
    #include <pthread.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    
    void *my_thread_func(void *arg) {
        printf("Поток запущен.\n");
        sleep(1);
        printf("Поток завершается.\n");
        return NULL;
    }
    
    int main() {
        pthread_t thread;
        pthread_attr_t attr;
    
        // 1. Инициализация структуры атрибутов
        pthread_attr_init(&attr);
    
        // 2. Установка атрибута отсоединённого состояния
        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    
        // 3. Создание потока с заданными атрибутами
        if (pthread_create(&thread, &attr, my_thread_func, NULL) != 0) {
            fprintf(stderr, "Ошибка при создании потока.\n");
            return 1;
        }
    
        // 4. Освобождение ресурсов структуры атрибутов
        pthread_attr_destroy(&attr);
    
        printf("Главный поток завершается.\n");
        pthread_exit(NULL); // Завершаем главный поток, не дожидаясь созданного
    }
    ```

- start_routine: функция, которую выполнит поток; возвращает void* (т.е. код может вернуть указатель, доступный при pthread_join).
  
  Другими словами — функция, которую выполнит поток; она принимает void* и возвращает void*

- arg: аргумент, который будет передан в start_routine (void *). Частый источник ошибок — передача указателя на локальную переменную, которая может выйти из области видимости. Лучше передавать указатель на malloc-структуру или целочисленное значение упакованное в heap / static.
  
  `*arg` используется для передачи данных в функцию, которую будет выполнять новый поток. Это указатель на данные, которые будут переданы в `start_routine`, функцию, которая запускается в новом потоке.
  
  - **Тип `void *`**: Чтобы обеспечить максимальную гибкость и передавать данные любого типа, аргумент имеет тип `void *`. Это универсальный указатель, который может указывать на данные любого типа.
  - **Один аргумент**: Функция `pthread_create` принимает только один аргумент для передачи в `start_routine`.
  - **Передача нескольких значений**: Чтобы передать несколько значений, нужно упаковать их в структуру, а затем передать указатель на эту структуру.
  - **Нулевой аргумент**: Если поток не требует никаких аргументов, в `pthread_create` можно передать `NULL`.
  
  Пример передачи одного аргумента:
  
  ```c
  #include <pthread.h>
  #include <stdio.h>
  
  void *print_message(void *arg) {
      char *message = (char *)arg; // Приведение типа (void *) к (char *)
      printf("%s\n", message);
      return NULL;
  }
  
  int main() {
      pthread_t thread_id;
      char *msg = "Привет из потока!";
      pthread_create(&thread_id, NULL, print_message, (void *)msg);
      pthread_join(thread_id, NULL);
      return 0;
  }
  ```
  
  Пример передачи нескольких аргументов (через структуру):
  
  ```c
  #include <pthread.h>
  #include <stdio.h>
  
  // Объявление структуры для передачи нескольких значений
  typedef struct {
      int id;
      char *name;
  } ThreadData;
  
  void *process_data(void *arg) {
      ThreadData *data = (ThreadData *)arg; // Приведение типа
      printf("Поток %d: %s\n", data->id, data->name);
      return NULL;
  }
  
  int main() {
      pthread_t thread_id;
      ThreadData data = {1, "Главный поток"};
  
      pthread_create(&thread_id, NULL, process_data, (void *)&data);
      pthread_join(thread_id, NULL);
      return 0;
  }
  ```
  
  Важное замечание
  
  - **Передача по указателю**: Убедитесь, что передаваемые данные будут доступны в течение всего времени работы нового потока. В примере выше с передачей `data`, она должна быть жива, пока поток её использует.
  - **Проблема с локальными переменными**: Не передавайте указатель на локальную переменную, если она может быть уничтожена до того, как поток успеет её использовать. В таких случаях лучше использовать динамическую память (`malloc`).
  - **Освобождение памяти**: Если вы используете динамическую память (`malloc`), не забудьте освободить её, когда она больше не нужна. Обычно это делает сам поток после использования данных.

- Возвращаемое значение:
  
  - Возвращает 0 при успехе, в противном случае — номер ошибки (positive error number), а не -1; errno не устанавливается. Ошибки:
    - `EAGAIN` — недостаточно ресурсов для создания потока (память или лимит потоков).
    - `EINVAL` — некорректный атрибут в attr.
    - `EPERM` — указанные привилегии/параметры планирования требуют прав (обычно при попытке выставить политики realtime). (Могут быть и другие, зависит от реализации.)

- Пример — корректное создание и ожидание:

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

// Функция, которую выполнит поток.
// Принимает void* и возвращает void*.
void *thread_func(void *arg) {
    int *p = (int *)arg;          // приводим к нужному типу
    printf("Внутри потока: got %d\n", *p);
    free(p);                      // освобождаем, т.к. выделяли в main
    return NULL;                  // return можно получить через pthread_join
}

int main(void) {
    pthread_t tid;
    int *arg = malloc(sizeof(int));
    if (!arg) return 1;
    *arg = 42;

    int r = pthread_create(&tid, NULL, thread_func, arg);
    if (r != 0) {
        // pthread_create возвращает код ошибки (не через errno)
        fprintf(stderr, "pthread_create failed: %d\n", r);
        free(arg);
        return 1;
    }

    // Ждём завершения потока и игнорируем возвращаемое значение
    pthread_join(tid, NULL);
    return 0;
}
```

---

### join vs detach:

- pthread_join(thread, &ret) — блокирует вызывающий поток, пока указанный поток не завершится; позволяет получить значение, возвращаемое потоком; освобождает ресурсы ОС.
- pthread_detach(thread) — говорим: "не буду ждать, освободи ресурсы автоматически, когда поток закончит." После detach делать pthread_join нельзя (вернёт EINVAL).

### Как поток заканчивает или приостанавливает работу?

- **Вызов `pthread_exit()`**: Поток может явно вызвать функцию `pthread_exit()` для завершения своей работы в любой момент, даже посреди выполнения. Это позволяет передать статус завершения, который можно получить из другого потока с помощью `pthread_join()`.
- **Отмена другим потоком**: Один поток может запросить отмену другого потока, вызвав функцию `pthread_cancel(thread)`. Этот механизм является более сложным и требует правильной обработки со стороны отменяемого потока, чтобы обеспечить безопасное завершение.
- **Завершение всего процесса**: Если любой из потоков в процессе, включая главный, вызывает функцию `exit()` или если главный поток завершается с помощью `return` (что не является хорошей практикой для многопоточных приложений), то весь процесс завершается, а вместе с ним и все остальные потоки.
  - Разница между `return` и `pthread_exit()`
    - **`return`**: Когда функция, которую выполняет поток, завершается с помощью `return`, происходит неявный вызов `pthread_exit()`. В результате поток завершается, и его код возврата становится доступен для `pthread_join()`.
    - **`pthread_exit()`**: Позволяет потоку завершиться в любой момент. Это полезно, когда нужно завершить поток раньше, чем будет достигнут конец его функции. Также, если вы используете `pthread_exit()` в главном потоке, он завершится, но не убьёт весь процесс, а будет ждать завершения других потоков.

Синтаксис: `int pthread_join(pthread_t thread, void **retval);` 

- **`thread`**: Идентификатор целевого потока, завершения которого нужно дождаться. Вы получаете этот идентификатор при создании потока с помощью `pthread_create`.
- **`retval`**: Указатель на указатель (`void **`). В это место будет скопирован статус завершения потока, переданный в `pthread_exit` или возвращённый из функции потока.
  - Если вы не заинтересованы в получении кода возврата, можно передать `NULL`.
  - Если поток завершился из-за отмены (`pthread_cancel`), в `retval` будет записано специальное значение `PTHREAD_CANCELED`. 

**Важно:**

- `pthread_join` может быть вызван только для **присоединяемого** (joinable) потока.
- Если не использовать `pthread_join` для присоединяемого потока, он превратится в "поток-зомби", потребляющий ресурсы. 

Синтаксис: `void pthread_exit(void *status);` 

`pthread_exit` используется самим потоком для завершения своей работы, возвращая статус завершения.

- **`status`**: Указатель (`void *`) на данные, которые будут переданы вызывающему `pthread_join` потоку.
  - Это может быть указатель на структуру, динамически выделенную память, или же целое число, приведённое к `void *`.
  - Если поток завершается без возврата данных, можно передать `NULL`. 

**Важно:**

- **Нельзя передавать указатель на локальную переменную** (`status`), так как память, выделенная для неё на стеке, будет освобождена после завершения потока, и указатель станет недействительным.
- `pthread_exit` **никогда не возвращается**. Вызов этой функции не завершает весь процесс, а только текущий поток.

---

##### Что происходит после завершения потока?

После завершения потока происходит следующее: 

- **`pthread_join()`**: Если поток был создан как "присоединяемый" (`joinable`), другой поток должен вызвать `pthread_join()` для получения статуса завершения и освобождения ресурсов.
- **Автоматическое освобождение ресурсов**: Если поток был создан как "отсоединённый" (`detached`), его ресурсы (включая стек) автоматически освобождаются при завершении, и его не нужно ждать.
- **Сигнал для ожидающих потоков**: Состояние объекта потока меняется на "сигнальное", что разблокирует любые другие потоки, которые ждали его завершения.

---

# Mutex

Мьютекс, или **mutex** (от **mut**ual **ex**clusion — «взаимное исключение»), — это примитив синхронизации, который используется для защиты общих ресурсов от одновременного доступа нескольких потоков. Его основная задача — гарантировать, что только один поток может войти в **критическую секцию** кода (участок, где происходит работа с общими данными) в любой момент времени.

Как работает мьютекс

Представьте себе телефонную будку. Только один человек может находиться внутри и пользоваться телефоном. 

- **Блокировка (lock)**: Прежде чем войти в будку, человек должен запереть дверь. В программировании поток должен «захватить» мьютекс.
- **Использование ресурса**: Пока мьютекс захвачен, поток может безопасно работать с общим ресурсом, не опасаясь, что другой поток вмешается.
- **Освобождение (unlock)**: Когда поток заканчивает работу, он «освобождает» мьютекс, открывая доступ для других потоков. 

Если другой поток попытается захватить мьютекс, который уже занят, он будет заблокирован и будет ждать, пока мьютекс не освободится. 

---

## Зачем нужен мьютекс?

Мьютекс помогает предотвратить **состояние гонки** (race condition) — ситуацию, когда результат выполнения программы зависит от того, какой из потоков первым получит доступ к общему ресурсу. 

**Пример:**  
Представьте два потока, которые одновременно пытаются увеличить общую переменную `счетчик`.

1. **Поток 1** считывает значение `счетчика` (допустим, 50).
2. Операционная система прерывает Поток 1 и запускает **Поток 2**.
3. **Поток 2** считывает то же значение `счетчика` (50), увеличивает его до 51 и записывает обратно.
4. Операционная система возобновляет работу Потока 1.
5. **Поток 1** продолжает свою работу, увеличивает значение 50 до 51 и записывает обратно.

В итоге, хотя оба потока выполнили операцию инкремента, итоговое значение `счетчика` увеличилось только на 1, а не на 2. Мьютекс гарантирует, что такая ситуация не произойдёт, позволяя каждому потоку завершить операцию инкремента по очереди.

Функции для работы с мьютексами (в `pthread`)

- `pthread_mutex_init()`: Инициализация мьютекса.
- `pthread_mutex_lock()`: Блокировка мьютекса (захват).
- `pthread_mutex_unlock()`: Разблокировка мьютекса (освобождение).
- `pthread_mutex_destroy()`: Уничтожение мьютекса, освобождение ресурсов.

Но перед тем, как понять, что за функции, надо разобраться, что такое семафор.

# Семафор

Семафор, как и мьютекс, — это примитив синхронизации, но он работает иначе и предназначен для более широкого круга задач. В то время как мьютекс обеспечивает **взаимное исключение** (только один поток имеет доступ), семафор — это механизм **сигнализации**, который управляет доступом к ограниченному количеству ресурсов.

Семафор — это переменная (счётчик), которая используется для управления доступом к определённому количеству ресурсов. Он имеет две основные операции:

- **`wait()`** (или `P()`): Уменьшает счётчик семафора. Если счётчик становится отрицательным, поток блокируется и ждёт, пока ресурс не станет доступным.
- **`signal()`** (или `V()`): Увеличивает счётчик семафора. Если есть заблокированные потоки, один из них разблокируется, так как ресурс освободился.

Существует два основных типа семафоров:

1. **Считающий (или счётный) семафор**: Может принимать любое неотрицательное целочисленное значение. Он используется для управления доступом к пулу однотипных ресурсов. Например, семафор с начальным значением 5 может управлять доступом к 5 принтерам.
2. **Двоичный семафор**: Может принимать только два значения: 0 и 1. Он работает аналогично мьютексу, но имеет ключевые отличия. 

---

Чем семафор отличается от мьютекса?

| Критерий               | Мьютекс (Mutex)                                                                                               | Семафор (Semaphore)                                                                                                                    |
| ---------------------- | ------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| **Механизм**           | **Блокировка**. Обеспечивает взаимное исключение. Один поток блокирует ресурс, использует его и разблокирует. | **Сигнализация**. Управляет доступом к нескольким экземплярам ресурса с помощью счётчика.                                              |
| **Количество потоков** | Только **один** поток может владеть мьютексом и находиться в критической секции.                              | Может разрешать доступ **нескольким** потокам одновременно, пока счётчик больше нуля.                                                  |
| **Владение**           | Мьютекс принадлежит потоку, который его заблокировал. Только этот поток может его разблокировать.             | Семафор не имеет владельца. Поток, который выполняет `signal()`, не обязательно должен быть тем же потоком, который выполнял `wait()`. |
| **Тип**                | Обычно это объект, обеспечивающий взаимное исключение.                                                        | Переменная (счётчик), управляющая доступным количеством ресурсов.                                                                      |
| **Предназначение**     | Защита **общего ресурса**, чтобы избежать состояний гонки.                                                    | **Координация** и **синхронизация** потоков, например, в проблеме "производитель-потребитель".                                         |

Сравнение на примере

- **Мьютекс:** Представьте туалет, в который может зайти только один человек. Как только человек заходит, он запирает дверь. Другие люди должны ждать, пока он не выйдет и не откроет дверь.
- **Семафор:** Представьте парковку с 10 свободными местами. Семафор будет иметь начальное значение 10. Каждый раз, когда машина (поток) заезжает, значение уменьшается на 1. Когда машина уезжает, значение увеличивается. Если все 10 мест заняты (значение 0), новые машины должны ждать.

## Функции для работы с мьютексами (в `pthread`)

1. `pthread_mutex_init()`

Эта функция динамически инициализирует мьютекс, готовя его к использованию. 

- **Синтаксис**: `int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);`
- **Аргументы**:
  - `mutex`: Указатель на объект мьютекса, который нужно инициализировать.
  - `attr`: Указатель на объект атрибутов мьютекса. Если вы передадите `NULL`, мьютекс будет создан с атрибутами по умолчанию, что является наиболее распространённым вариантом.
- **Что делает**:
  - Создаёт и инициализирует мьютекс, устанавливая его в разблокированное состояние.
  - Если передан `attr`, устанавливает указанные атрибуты (например, тип мьютекса: нормальный, рекурсивный или с проверкой ошибок).
  - **Важно**: Попытка инициализировать уже инициализированный мьютекс приводит к неопределённому поведению.

2. `pthread_mutex_lock()`

Эта функция захватывает мьютекс, блокируя его.

- **Синтаксис**: `int pthread_mutex_lock(pthread_mutex_t *mutex);`
- **Аргументы**:
  - `mutex`: Указатель на объект мьютекса, который нужно заблокировать.
- **Что делает**:
  - Если мьютекс не заблокирован, он блокируется и поток-вызыватель становится его владельцем. Функция немедленно возвращает управление.
  - Если мьютекс уже заблокирован другим потоком, вызывающий поток блокируется до тех пор, пока мьютекс не освободится.
  - Если мьютекс уже заблокирован текущим потоком, поведение зависит от типа мьютекса:
    - **Нормальный мьютекс (по умолчанию)**: Поток блокируется, что приводит к взаимной блокировке (deadlock).
    - **Рекурсивный мьютекс**: Счётчик блокировок увеличивается, и функция сразу возвращает управление.
    - **Мьютекс с проверкой ошибок**: Функция возвращает ошибку, сигнализируя о попытке рекурсивной блокировки. 

3. `pthread_mutex_unlock()`

Эта функция разблокирует мьютекс.

- **Синтаксис**: `int pthread_mutex_unlock(pthread_mutex_t *mutex);`
- **Аргументы**:
  - `mutex`: Указатель на объект мьютекса, который нужно разблокировать.
- **Что делает**:
  - Снимает блокировку с мьютекса, делая его доступным для других потоков.
  - Если после разблокировки есть потоки, ожидающие доступа к мьютексу, один из них (в соответствии с политикой планировщика) будет разблокирован и станет владельцем мьютекса.
  - **Важно**: Согласно стандарту POSIX, только поток-владелец мьютекса может его разблокировать. Попытка разблокировать мьютекс, принадлежащий другому потоку, приводит к неопределённому поведению. 

4. `pthread_mutex_destroy()`

Эта функция уничтожает мьютекс, освобождая выделенные для него ресурсы.

- **Синтаксис**: `int pthread_mutex_destroy(pthread_mutex_t *mutex);`
- **Аргументы**:
  - `mutex`: Указатель на объект мьютекса, который нужно уничтожить.
- **Что делает**:
  - Уничтожает мьютекс, делая его неинициализированным.
  - Мьютекс должен быть разблокирован перед уничтожением.
  - После уничтожения мьютекс не должен использоваться до повторной инициализации.
  - **Важно**: В некоторых реализациях, например в LinuxThreads, если мьютекс не хранит никаких ресурсов, эта функция может ничего не делать, кроме проверки состояния мьютекса.

Пример:

```c
#include <pthread.h>
#include <stdio.h>

int counter = 0;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

void *inc(void *arg) {
    for (int i = 0; i < 100000; ++i) {
        pthread_mutex_lock(&m);    // начинаем критическую секцию
        counter++;                 // безопасный доступ
        pthread_mutex_unlock(&m);  // заканчиваем критическую секцию
    }
    return NULL;
}
```

### Semaphore — идея и базовый API

- sem_t s;
- sem_init(&s, pshared, initial_value); // pshared=0 для потоков в одном процессе
- sem_wait(&s); // ждёт, пока значение >0, затем уменьшает
- sem_post(&s); // увеличивает значение (и пробуждает один waiting поток)
- sem_destroy(&s);

Когда семафор полезен:

- Подсчёт доступных ресурсов (N одновременных подключений).
- Producer/Consumer: два семафора (empty и full) + mutex для доступа к буферу.

Пример:

```c
#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>

#define N 4

int buffer[N];
int in = 0, out = 0;
pthread_mutex_t buf_mutex = PTHREAD_MUTEX_INITIALIZER;
sem_t empty; // сколько свободных слотов
sem_t full;  // сколько заполненных слотов

void *producer(void *arg) {
    int id = (int)(long)arg; // простой id потока
    for (int i = 0; i < 10; ++i) {
        int item = id * 100 + i;    // формируем элемент
        sem_wait(&empty);           // ждём, пока есть свободный слот
        pthread_mutex_lock(&buf_mutex); // защищаем доступ к buffer[]
        buffer[in] = item;
        in = (in + 1) % N;
        pthread_mutex_unlock(&buf_mutex);
        sem_post(&full);            // говорим: появился заполненный слот
    }
    return NULL;
}

void *consumer(void *arg) {
    (void)arg;
    for (int i = 0; i < 20; ++i) {
        sem_wait(&full);            // ждём, пока есть элемент
        pthread_mutex_lock(&buf_mutex);
        int item = buffer[out];
        out = (out + 1) % N;
        pthread_mutex_unlock(&buf_mutex);
        sem_post(&empty);           // освободили слот
        printf("consumed %d\n", item);
    }
    return NULL;
}

int main(void) {
    pthread_t p1, p2, c;
    sem_init(&empty, 0, N); // N пустых слотов
    sem_init(&full, 0, 0);  // 0 заполненных

    pthread_create(&p1, NULL, producer, (void*)(long)1);
    pthread_create(&p2, NULL, producer, (void*)(long)2);
    pthread_create(&c, NULL, consumer, NULL);

    pthread_join(p1, NULL);
    pthread_join(p2, NULL);
    pthread_join(c, NULL);

    sem_destroy(&empty);
    sem_destroy(&full);
    return 0;
}
```

Комментарий: семафоры управляют количеством элементов/слотов; mutex защищает структуру buffer от одновременного доступа.

### Частые ошибки

- Не передавайте адрес локальной переменной в аргумент потока. Используй malloc или глобальную структуру.
- Всегда проверяйте возвратные коды (особенно pthread_create, pthread_join, sem_*).
- Condition variables проверяйте условие в цикле: while (!cond) pthread_cond_wait(...)
- Никогда не освобождайте mutex, который не захватывал ты сам.
- Не держите mutex долго (например, не делай ввод/вывод внутри критической секции).
- Для отладки гонок используйте ThreadSanitizer (-fsanitize=thread) или Helgrind (valgrind).

###### Короткая шпаргалка по возвратам и сигналам ошибок

- pthread_create: 0 или код ошибки (EAGAIN, EINVAL, EPERM).
- pthread_join: 0 или ESRCH/EINVAL/EDEADLK.
- pthread_mutex_lock: 0 или EINVAL/EDEADLK/EOWNERDEAD (robust).
- sem_wait/sem_post: возвращает 0 при успехе, -1 при ошибке и errno установлен.

# Пример

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

#define ROWS 100
#define COLS 100
#define NUM_THREADS 4

// Глобальная переменная для итоговой суммы
long long total_sum = 0;
// Глобальный мьютекс для защиты total_sum
pthread_mutex_t mutex;

// Структура для передачи данных в поток
typedef struct {
    int row_index;
    int (*matrix)[COLS];
} ThreadData;

// Матрица для примера
int matrix[ROWS][COLS];

// Функция, которую будет выполнять каждый поток
void *sum_matrix_row(void *arg) {
    ThreadData *data = (ThreadData *)arg;
    int row = data->row_index;
    long long row_sum = 0;

    // Вычисление суммы для одной строки
    for (int j = 0; j < COLS; ++j) {
        row_sum += data->matrix[row][j];
    }

    // Критическая секция: обновление общей суммы
    pthread_mutex_lock(&mutex);       // Захват мьютекса
    total_sum += row_sum;             // Обновление общей переменной
    pthread_mutex_unlock(&mutex);     // Освобождение мьютекса

    pthread_exit(NULL);
}

int main() {
    pthread_t threads[ROWS];
    ThreadData thread_data[ROWS];

    // Инициализация матрицы
    for (int i = 0; i < ROWS; ++i) {
        for (int j = 0; j < COLS; ++j) {
            matrix[i][j] = 1; // Простая инициализация для теста
        }
    }

    // Инициализация мьютекса
    pthread_mutex_init(&mutex, NULL);

    // Создание и запуск потоков для каждой строки
    for (int i = 0; i < ROWS; ++i) {
        thread_data[i].row_index = i;
        thread_data[i].matrix = matrix;

        pthread_create(&threads[i], NULL, sum_matrix_row, (void *)&thread_data[i]);
    }

    // Ожидание завершения всех потоков
    for (int i = 0; i < ROWS; ++i) {
        pthread_join(threads[i], NULL);
    }

    // Уничтожение мьютекса
    pthread_mutex_destroy(&mutex);

    printf("Сумма всех элементов матрицы: %lld\n", total_sum);

    return 0;
}
```

Преимущества

- **Простота**: Этот подход проще для понимания и реализации, чем разбиение задачи на части с последующим сбором результатов.
- **Гибкость**: Каждый поток может работать над своей частью независимо от других.
- **Корректность**: Гарантируется, что итоговая сумма будет вычислена правильно, без ошибок, вызванных состоянием гонки.

Недостатки

- **Снижение производительности**: Использование мьютекса может привести к **конфликту блокировок**. Если слишком много потоков пытаются одновременно обновить одну и ту же переменную, они будут вынуждены ждать, что может снизить общую производительность.
- **Масштабируемость**: Эффективность этого подхода может уменьшаться при увеличении числа потоков, так как contention на мьютексе будет расти.

---

# Сортировка

### Алгоритм Быстрой Сортировки (Quicksort)

Прежде чем говорить о параллельной версии, давай вспомним, как работает обычная быстрая сортировка.

Это рекурсивный алгоритм, работающий по принципу "разделяй и властвуй":

1. **Выбор опорного элемента (pivot):** Взять любой элемент из массива (часто берут средний, первый или случайный).
2. **Разделение (partition):** Перераспределить массив так, чтобы все элементы, которые меньше опорного, оказались слева от него, а все, которые больше — справа.
3. **Рекурсия:** Рекурсивно применить шаги 1 и 2 к двум получившимся подмассивам (левому и правому).

Процесс продолжается до тех пор, пока сортируемый подмассив не будет содержать один или ноль элементов.

## Основные шаги алгоритма qsort

Алгоритм быстрой сортировки можно разбить на три основных этапа: 

1. **Выбор опорного элемента (pivot)**:  
   Сначала из массива выбирается один элемент, который будет служить «опорным». Есть разные стратегии выбора:
   - Всегда первый элемент.
   - Всегда последний элемент.
   - Случайный элемент.
   - Медиана из трёх (первый, средний и последний).
2. **Разбиение (partition)**:  
   Все остальные элементы массива переупорядочиваются таким образом, чтобы:
   - Все элементы, которые **меньше** опорного, оказались слева от него.
   - Все элементы, которые **больше** опорного, оказались справа от него.
   - В результате опорный элемент встаёт на своё окончательное место в отсортированном массиве.
3. **Рекурсивный вызов**:  
   Алгоритм рекурсивно применяется к двум подмассивам — слева и справа от опорного элемента. Этот процесс повторяется до тех пор, пока подмассив не будет состоять из одного элемента или вообще не будет содержать элементов. Массив из одного элемента по определению уже отсортирован.

<img title="" src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="" width="527">

Визуальный пример:

<img title="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Quicksort-diagram.svg/330px-Quicksort-diagram.svg.png" alt="" width="217" data-align="center">

Пример быстрой сортировки. Здесь опорным является последний элемент массива (ячейка чёрного цвета), что в отсортированных массивах может приводить к ухудшению производительности

---

## Пример работы

Давайте проследим, как работает быстрая сортировка на примере массива `[10, 80, 30, 90, 40, 50, 70]`.

1. **Первый вызов**:
   - **Массив**: `[10, 80, 30, 90, 40, 50, 70]`
   - **Выбираем опорный элемент**: В качестве опорного возьмём последний элемент, `70`.
   - **Разбиение**: Переупорядочиваем массив так, чтобы все элементы меньше `70` были слева, а больше — справа.
     - Массив после разбиения может выглядеть так: `[10, 30, 40, 50, 70, 80, 90]`.
     - Элемент `70` теперь находится на своём окончательном месте.
2. **Второй вызов (рекурсия для левого подмассива)**:
   - **Массив**: `[10, 30, 40, 50]`
   - **Выбираем опорный**: Возьмём `50`.
   - **Разбиение**: Элементы меньше `50` (`10, 30, 40`) слева, больше `50` справа.
     - Массив: `[10, 30, 40, 50]`.
     - Опорный `50` на своём месте.
3. **Третий вызов (рекурсия для правого подмассива)**:
   - **Массив**: `[80, 90]`
   - **Выбираем опорный**: Возьмём `90`.
   - **Разбиение**: Элементы меньше `90` (`80`) слева.
     - Массив: `[80, 90]`.

Этот процесс продолжается рекурсивно, пока все подмассивы не будут отсортированы.

Производительность 

- **В среднем**: Быстрая сортировка имеет сложность ![](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)$O(n\cdot log(n)$, что делает её одной из самых быстрых. Это обусловлено тем, что каждый шаг разбивает массив на две части, и глубина рекурсии составляет примерно ![](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)$log(n)$

- **В худшем случае**: $O(n^2)$. Это происходит, когда выбор опорного элемента постоянно неудачен, например, если массив уже отсортирован, а опорным элементом всегда выбирается первый (или последний) элемент. В таком случае разбиения не происходит, и алгоритм каждый раз работает с почти полным массивом. Современные реализации стараются избегать такого поведения.

- **Преимущества**: Высокая производительность в среднем случае, сортировка происходит "на месте" (in-place), то есть не требует дополнительной памяти, что делает её очень эффективной.

# Пример qsort для массива целых чисел

```c
#include <stdio.h>

// 1. Вспомогательная функция для обмена двух элементов
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 2. Функция для разделения массива
//Возьмём массив: [10, 7, 8, 9, 1, 5]
//Здесь low = 0, high = 5.
int partition(int arr[], int low, int high) {
    // 1. Выбираем опорный элемент (pivot)
    // В данном примере - последний элемент подмассива.
    int pivot = arr[high]; // pivot = arr[5] = 5

    // 2. Инициализируем индекс меньшего элемента
    // Это будет граница между меньшими и большими элементами.
    int i = (low - 1); // i = -1

    // 3. Проходим по всем элементам от low до high-1 (По этим эелементам [10, 7, 8, 9, 1])
    for (int j = low; j < high; j++) {
        // Текущий массив: [10, 7, 8, 9, 1, 5]
        // j будет принимать значения 0, 1, 2, 3, 4.

        // a. Если текущий элемент меньше или равен опорному (5)
        if (arr[j] <= pivot) {
            i++; // Увеличиваем индекс меньшего элемента (Увеличим индекс только на элементе 1, при j = 4)
            // Тогда получим i = 0 и поменяем местами 10 и 1 и в итоге получим [1, 7, 8, 9, 10, 5]
            swap(&arr[i], &arr[j]); // Меняем местами
        }
    }

    // 4. После цикла: ставим опорный элемент на его место
    // Обмениваем элемент, следующий за последним меньшим элементом (i+1), 
    // с опорным элементом (arr[high]).
    // Получается [1, 5, 8, 9, 10, 7]
    swap(&arr[i + 1], &arr[high]);

    // 5. Возвращаем индекс опорного элемента i + 1 = 1
    return (i + 1);
}


// 3. Главная рекурсивная функция быстрой сортировки
// low и high — это индексы массива, которые определяют границы (начало и конец) того подмассива, с которым работает
// текущий вызов быстрой сортировки.
void quickSort(int arr[], int low, int high) {
    // Базовый случай рекурсии: если low >= high, подмассив отсортирован
    // low == high: Подмассив состоит всего из одного элемента
    // low > high: Эта ситуация возникает, когда один из подмассивов, созданных partition, пуст. 
    // Например, если опорный элемент оказался самым маленьким или самым большим в подмассиве, один из рекурсивных
    // вызовов будет иметь low больше, чем high. Это также означает, что сортировка для этого подмассива завершена.
    // Например, если мы передадим значение low = 0 hight = -1 (Поледний элемент оказался самым маленьким)
    // Он встал на место первого элемента и выполнится вызов для low = 0 hight = n
    if (low < high) {
        // Находим индекс, где должен стоять опорный элемент
        int pi = partition(arr, low, high);

        // Рекурсивно сортируем элементы до и после опорного
        // Для нашего массива вызываем сортировку для массива low = 0, low = 0 => Уже отсортирован
        // Второй случай low = 2 hight = 5 => Сортируем массив [8, 9, 10, 7]
        // И так мы будем дейстовать до тех пор, пока не отсортрируем весь массив.
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// Вспомогательная функция для вывода массива
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// Главная функция для тестирования
int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Исходный массив: \n");
    printArray(arr, n);

    quickSort(arr, 0, n - 1);

    printf("Отсортированный массив: \n");
    printArray(arr, n);

    return 0;
}
```

---

# Параллельная Быстрая Сортировка

А теперь самое интересное: как заставить несколько "поваров" (потоков) сортировать один массив?

Идея проста: **распараллелить рекурсивные вызовы**.

1. Мы, как "главный поток", выполняем первый шаг быстрой сортировки: выбираем опорный элемент и разделяем массив на две части (левую `L` и правую `R`).
2. А вот дальше начинается магия. Вместо того чтобы самим (рекурсивно) сортировать обе части, мы делаем следующее:
   - Создаём **новый поток** и даём ему задание отсортировать левую часть `L`.
   - Сами, в это же время, начинаем сортировать правую часть `R`.

Теперь две части массива сортируются **одновременно**!

Каждый из этих потоков, в свою очередь, может также разделить свою часть массива на две и создать ещё один поток для одной из половин.

**Ограничение (важно для задания):** Создавать новый поток для каждого подмассива — плохая идея. Это приведёт к созданию тысяч потоков, что очень неэффективно (создание потока — затратная операция).

Поэтому вводится **ограничение на количество потоков**, как в задании (`ключ запуска программы`).

### А как реализовать?

- Напишем функцию `qpsort(int* array, int low, int high, int threads_left)`.
- Внутри неё, после разделения массива, проверим `threads_left`.
- Если `threads_left > 0`, создаём новый поток (`pthread_create`) для сортировки одной половины, передав ему `threads_left - 1`. Сами рекурсивно вызовем сортировку для второй половины с тем же `threads_left`. Не забудь дождаться завершения дочернего потока (`pthread_join`).
- Если `threads_left == 0`, просто вызовем обычную, последовательную сортировку для обеих половин.

## Исследование ускорения и эффективности:

- **Ускорение (Speedup):** Это отношение времени выполнения последовательного алгоритма (`T1`) ко времени выполнения параллельного алгоритма на `N` потоках (`TN`). `Speedup(N) = T1 / TN`
  
  Мы замеряем время работы программы с 1 потоком, потом с 2, 4, 8 и т.д., и строим график. В идеале, на 4 потоках программа должна работать в 4 раза быстрее. На практике так не бывает из-за накладных расходов на создание потоков и синхронизацию.

- **Эффективность (Efficiency):** Это показывает, насколько хорошо используются выделенные ресурсы. 
  
  `Efficiency(N) = Speedup(N) / N` 
  
  Если эффективность равна 1 (или 100%), это идеальное использование. Обычно она меньше 1. Наша задача — объяснить, почему так происходит (те самые накладные расходы).

# А как проверять?

Чтобы проверить за какое время выполняется программа в linux, нужно использовать команду time перед командой для выполнения:

```bash
time ./main -t <N_thread_max>
```

Каждая из трёх строк в выводе команды `time` предоставляет информацию о времени, потраченном на выполнение программы `main`, но с разной точки зрения

- **`real` (реальное время):** 
  - **Что это:** Общее время, прошедшее с момента запуска программы до её завершения. Это время, которое вы увидели бы на обычном секундомере.
  - **Почему оно может быть больше, чем `user` и `sys`:** В это время включаются все задержки, не связанные с активной работой процессора. Например, время, которое программа потратила на ожидание:
    - завершения операций ввода-вывода (чтение файлов, ожидание ввода пользователя)
    - пока другие процессы используют процессор
- **`user` (пользовательское время):** 
  - **Что это:** Общее время, которое процессор потратил на выполнение кода самой программы, когда она работала в режиме пользователя (user-space).
  - **Что не учитывается:** В это время не входит время, которое процессор тратил на выполнение системных вызовов от имени вашей программы.
- **`sys` (системное время):**
  - **Что это:** Общее время, которое процессор потратил на выполнение системных вызовов в режиме ядра (kernel-space) от имени вашей программы.
  - **Примеры системных вызовов:** Управление памятью, чтение из файла и запись в него, запуск новых процессов и т. д..
